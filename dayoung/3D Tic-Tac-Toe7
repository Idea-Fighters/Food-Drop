import numpy as np

def check_winner(board):
    for i in range(3):
        if np.all(board[i,:,:] == board[i,0,0]) and board[i,0,0] != 0:
            return board[i,0,0]
        if np.all(board[:,i,:] == board[0,i,0]) and board[0,i,0] != 0:
            return board[0,i,0]
        if np.all(board[:,:,i] == board[0,0,i]) and board[0,0,i] != 0:
            return board[0,0,i]

    for i in range(3):
        if np.all(board[i,:,:] == board[i,0,0]) and board[i,0,0] != 0:
            return board[i,0,0]

    for i in range(3):
        if np.all(board[:,i,:] == board[0,i,0]) and board[0,i,0] != 0:
            return board[0,i,0]

    if np.all(board.diagonal() == board[0,0,0]) and board[0,0,0] != 0:
        return board[0,0,0]

    if np.all(np.fliplr(board).diagonal() == board[0,2,0]) and board[0,2,0] != 0:
        return board[0,2,0]

    return 0

def print_board(board):
    for layer in board:
        print(layer)
        print()

def ai_move(board, player):
    empty_cells = [(x, y, z) for x in range(3) for y in range(3) for z in range(3) if board[x, y, z] == 0]
    return random.choice(empty_cells)

def play_game():
    board = np.zeros((3, 3, 3), dtype=int)
    player = 1
    while True:
        print_board(board)
        if player == 1:
            x, y, z = map(int, input(f"Player {player}, enter your move (x y z): ").split())
        else:
            x, y, z = ai_move(board, player)
            print(f"AI Player {player} moves: ({x}, {y}, {z})")
        if board[x, y, z] != 0:
            print("Invalid move! Try again.")
            continue
        board[x, y, z] = player
        winner = check_winner(board)
        if winner != 0:
            print_board(board)
            print(f"Player {winner} wins!")
            break
        player = 3 - player

play_game()
